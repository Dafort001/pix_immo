Replit Task: E-Mail-OTP-Login & Verifizierung vorbereiten (SES-Adapter, ohne echte Secrets)
Implementiere bitte einen E-Mail-basierten OTP-Login mit Verifizierung, ohne dass aktuell echte AWS-SES-Zugangsdaten gesetzt sein müssen. Die Secrets werden später von mir ergänzt. Die Implementierung soll aber technisch vollständig sein.
1. User-Verifizierung in der Datenbank


Erweitere die users-Tabelle um ein Feld zur E-Mail-Verifizierung:


email_verified_at (TIMESTAMP, NULL = nicht verifiziert).




Setze email_verified_at nur nach erfolgreicher OTP-Validierung.


Bestehende Logik nicht refactoren, nur ergänzen.


2. OTP-Flow (Backend-Routen)
Lege zwei API-Routen an (oder erweitere bestehende Auth-Routen), passend zur bestehenden Struktur (z. B. Hono/Lucia):


POST /auth/request-otp


Input: { email: string }


Ablauf:


E-Mail normalisieren (trim, lowercase).


Falls User existiert: weiter.


Falls User nicht existiert: neuen User mit dieser E-Mail anlegen (nicht verifiziert).


6-stelligen OTP-Code generieren (z. B. 000000–999999).


Code + Ablaufzeit (z. B. 10–15 Minuten) in einer passenden Struktur speichern
(eigene otp_codes-Tabelle oder vorhandenes Token-System, inkl. E-Mail-Referenz).


Über eine Hilfsfunktion sendOtpEmail(email, code) den Versand anstoßen.


Rate-Limit pro E-Mail und ggf. pro IP beachten (z. B. max. 1 aktiver Code pro Minute).


Response: generische Erfolgsmeldung (kein Hinweis, ob User existiert oder nicht).






POST /auth/verify-otp


Input: { email: string, code: string }


Ablauf:


E-Mail normalisieren wie oben.


Passenden OTP-Eintrag suchen (E-Mail + Code, nicht abgelaufen, nicht bereits benutzt).


Falls ungültig → Fehler (z. B. 400, „Code ungültig oder abgelaufen“).


Falls gültig:


OTP-Eintrag als benutzt/invalid markieren.


Beim zugehörigen User email_verified_at setzen (falls noch NULL).


Login-/Session-Mechanismus verwenden, der im Projekt bereits existiert (z. B. Lucia-Session erstellen).




Response: Erfolg + relevante Session-/User-Infos wie im System üblich.






3. E-Mail-Sende-Adapter (SES-Stub für jetzt)
Implementiere eine zentrale Helper-Funktion, z. B.:


sendOtpEmail(to: string, code: string): Promise<void>


Verhalten:


Lies folgende ENV-Variablen:


AWS_SES_ACCESS_KEY_ID


AWS_SES_SECRET_ACCESS_KEY


AWS_SES_REGION (Standard: eu-central-1)


AWS_SES_FROM_ADDRESS (Standard: no-reply@pix.immo)




Wenn eine der nötigen Variablen nicht gesetzt ist:


Kein echter Versand, stattdessen:


Sauberes Logging im Server-Log: Zieladresse + Code + Hinweis „SES not configured – dry run only“.




In diesem Fall aber trotzdem den normalen Flow weiterlaufen lassen, damit ich lokal testen kann.




Wenn alle Variablen gesetzt sind:


Verwende AWS SES (Region: eu-central-1), um eine Plaintext-E-Mail zu senden:


From: AWS_SES_FROM_ADDRESS


To: to


Subject: Dein pix.immo Login-Code


Body (reiner Text), etwa:


kurze Begrüßung


der 6-stellige Code


Hinweis auf Gültigkeitsdauer (z. B. 10 Minuten)


kein Link, nur Text.








4. Security & Rate-Limiting


Pro E-Mail-Adresse:


Max. 1 neuer OTP-Code pro kurzer Zeitspanne (z. B. 1 Minute), um Spam zu verhindern.




OTP-Codes:


Haben ein Ablaufdatum.


Nach erfolgreicher Verwendung sofort invalidieren.




Kein „Auto-Verify“:


Ohne gültigen OTP darf email_verified_at niemals gesetzt werden.




5. Integration in bestehende Auth-Logik


Falls bereits eine Session-/Auth-Library genutzt wird (z. B. Lucia):


Nutze den vorhandenen Mechanismus, um nach erfolgreicher OTP-Validierung eine Session zu erstellen.




Stelle sicher, dass spätere Bereiche (Buchung, Galerie etc.) email_verified_at als Bedingung nutzen können:


z. B. ein Helper requireVerifiedEmail(user) oder entsprechendes Flag im Session-Check.





Die Secrets (AWS_SES_*) trage ich später selbst in der Umgebung ein. Bitte die Implementierung so bauen, dass das System auch ohne gesetzte SES-ENV-Variablen lauffähig ist (Dry-Run mit Logging), aber produktiv sofort auf SES umschaltet, sobald die Variablen vorhanden sind.